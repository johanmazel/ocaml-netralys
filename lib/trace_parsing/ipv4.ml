(* This file was autogenerated by MPL *)
module Ipv4 = struct
  open Mpl_stdlib
  exception Bad_packet of string

  type protocol_t = [
    |`ICMP
    |`IGMP
    |`TCP
    |`UDP
    |`Unknown of int
  ]

  let protocol_marshal (a:protocol_t) =
    match a with
    |`ICMP -> 1
    |`IGMP -> 2
    |`TCP -> 6
    |`UDP -> 17
    |`Unknown x -> x

  let protocol_unmarshal a : protocol_t =
    match a with
    |1 -> `ICMP
    |2 -> `IGMP
    |6 -> `TCP
    |17 -> `UDP
    |x -> `Unknown x

  let protocol_to_string (a:protocol_t) =
    match a with
    |`ICMP -> "ICMP"
    |`IGMP -> "IGMP"
    |`TCP -> "TCP"
    |`UDP -> "UDP"
    |`Unknown x -> Printf.sprintf "%d" x

  let protocol_of_string s : protocol_t option = match s with
    |"ICMP" -> Some `ICMP
    |"IGMP" -> Some `IGMP
    |"TCP" -> Some `TCP
    |"UDP" -> Some `UDP
    |_ -> None

  type tos_reliability_t = [
    |`Normal
    |`Low
    |`Unknown of int
  ]

  let tos_reliability_marshal (a:tos_reliability_t) =
    match a with
    |`Normal -> 0
    |`Low -> 1
    |`Unknown x -> x

  let tos_reliability_unmarshal a : tos_reliability_t =
    match a with
    |0 -> `Normal
    |1 -> `Low
    |x -> `Unknown x

  let tos_reliability_to_string (a:tos_reliability_t) =
    match a with
    |`Normal -> "Normal"
    |`Low -> "Low"
    |`Unknown x -> Printf.sprintf "%d" x

  let tos_reliability_of_string s : tos_reliability_t option = match s with
    |"Normal" -> Some `Normal
    |"Low" -> Some `Low
    |_ -> None

  type tos_throughput_t = [
    |`Normal
    |`Low
    |`Unknown of int
  ]

  let tos_throughput_marshal (a:tos_throughput_t) =
    match a with
    |`Normal -> 0
    |`Low -> 1
    |`Unknown x -> x

  let tos_throughput_unmarshal a : tos_throughput_t =
    match a with
    |0 -> `Normal
    |1 -> `Low
    |x -> `Unknown x

  let tos_throughput_to_string (a:tos_throughput_t) =
    match a with
    |`Normal -> "Normal"
    |`Low -> "Low"
    |`Unknown x -> Printf.sprintf "%d" x

  let tos_throughput_of_string s : tos_throughput_t option = match s with
    |"Normal" -> Some `Normal
    |"Low" -> Some `Low
    |_ -> None

  type tos_delay_t = [
    |`Normal
    |`Low
    |`Unknown of int
  ]

  let tos_delay_marshal (a:tos_delay_t) =
    match a with
    |`Normal -> 0
    |`Low -> 1
    |`Unknown x -> x

  let tos_delay_unmarshal a : tos_delay_t =
    match a with
    |0 -> `Normal
    |1 -> `Low
    |x -> `Unknown x

  let tos_delay_to_string (a:tos_delay_t) =
    match a with
    |`Normal -> "Normal"
    |`Low -> "Low"
    |`Unknown x -> Printf.sprintf "%d" x

  let tos_delay_of_string s : tos_delay_t option = match s with
    |"Normal" -> Some `Normal
    |"Low" -> Some `Low
    |_ -> None

  type tos_precedence_t = [
    |`Routine
    |`Priority
    |`Immediate
    |`Flash
    |`Flash_override
    |`ECP
    |`Internetwork_control
    |`Network_control
    |`Unknown of int
  ]

  let tos_precedence_marshal (a:tos_precedence_t) =
    match a with
    |`Routine -> 0
    |`Priority -> 1
    |`Immediate -> 2
    |`Flash -> 3
    |`Flash_override -> 4
    |`ECP -> 5
    |`Internetwork_control -> 6
    |`Network_control -> 7
    |`Unknown x -> x

  let tos_precedence_unmarshal a : tos_precedence_t =
    match a with
    |0 -> `Routine
    |1 -> `Priority
    |2 -> `Immediate
    |3 -> `Flash
    |4 -> `Flash_override
    |5 -> `ECP
    |6 -> `Internetwork_control
    |7 -> `Network_control
    |x -> `Unknown x

  let tos_precedence_to_string (a:tos_precedence_t) =
    match a with
    |`Routine -> "Routine"
    |`Priority -> "Priority"
    |`Immediate -> "Immediate"
    |`Flash -> "Flash"
    |`Flash_override -> "Flash_override"
    |`ECP -> "ECP"
    |`Internetwork_control -> "Internetwork_control"
    |`Network_control -> "Network_control"
    |`Unknown x -> Printf.sprintf "%d" x

  let tos_precedence_of_string s : tos_precedence_t option = match s with
    |"Routine" -> Some `Routine
    |"Priority" -> Some `Priority
    |"Immediate" -> Some `Immediate
    |"Flash" -> Some `Flash
    |"Flash_override" -> Some `Flash_override
    |"ECP" -> Some `ECP
    |"Internetwork_control" -> Some `Internetwork_control
    |"Network_control" -> Some `Network_control
    |_ -> None

  class o
    ~(options_length:int)
    ~(data_length:int)
    (env:env) =
    object(self)
      method env = env_at env 0 self#sizeof
      method sizeof = data_length+options_length+4+4+2+1+1+1+1+2+2+1+1




      method tos_precedence =
        let __bitdummy0 = Mpl_byte.to_int (Mpl_byte.at env (0)) in
        let __bitdummy1 = Mpl_byte.to_int (Mpl_byte.at env (1)) in
        let tos_precedence = ((__bitdummy1 lsr 5) lsl 0) in
        tos_precedence_unmarshal tos_precedence
      (* set_tos_precedence unsupported for now (type bit) *)

      method tos_delay =
        let __bitdummy1 = Mpl_byte.to_int (Mpl_byte.at env (1)) in
        let tos_delay = (((__bitdummy1 lsr 4) land 1) lsl 0) in
        tos_delay_unmarshal tos_delay
      (* set_tos_delay unsupported for now (type bit) *)

      method tos_throughput =
        let __bitdummy1 = Mpl_byte.to_int (Mpl_byte.at env (1)) in
        let tos_throughput = (((__bitdummy1 lsr 3) land 1) lsl 0) in
        tos_throughput_unmarshal tos_throughput
      (* set_tos_throughput unsupported for now (type bit) *)

      method tos_reliability =
        let __bitdummy1 = Mpl_byte.to_int (Mpl_byte.at env (1)) in
        let tos_reliability = (((__bitdummy1 lsr 2) land 1) lsl 0) in
        tos_reliability_unmarshal tos_reliability
      (* set_tos_reliability unsupported for now (type bit) *)



      method id =
        Mpl_uint16.to_int (Mpl_uint16.at env (1+1+2))
      method set_id v : unit =
        Mpl_uint16.marshal (env_at env (1+1+2) 2) (Mpl_uint16.of_int v)



      method dont_fragment =
        let __bitdummy2 = Mpl_byte.to_int (Mpl_byte.at env (1+1+2+2)) in
        (((__bitdummy2 lsr 6) land 1) lsl 0)
      (* set_dont_fragment unsupported for now (type bit) *)

      method can_fragment =
        let __bitdummy2 = Mpl_byte.to_int (Mpl_byte.at env (1+1+2+2)) in
        (((__bitdummy2 lsr 5) land 1) lsl 0)
      (* set_can_fragment unsupported for now (type bit) *)


      method frag_offset =
        let __bitdummy2 = Mpl_byte.to_int (Mpl_byte.at env (1+1+2+2)) in
        let __bitdummy3 = Mpl_byte.to_int (Mpl_byte.at env (1+1+2+2+1)) in
        (__bitdummy3 lsl 0) + (((__bitdummy2 lsr 0) land 31) lsl 8)
      (* set_frag_offset unsupported for now (type bit) *)

      method ttl =
        Mpl_byte.to_int (Mpl_byte.at env (1+1+2+2+1+1))
      method set_ttl v : unit =
        Mpl_byte.marshal (env_at env (1+1+2+2+1+1) 1) (Mpl_byte.of_int v)

      method protocol =
        let protocol = Mpl_byte.to_int (Mpl_byte.at env (1+1+2+2+1+1+1)) in
        protocol_unmarshal protocol
      method set_protocol v : unit =
        Mpl_byte.marshal (env_at env (1+1+2+2+1+1+1) 1) (Mpl_byte.of_int v)

      method checksum =
        Mpl_uint16.to_int (Mpl_uint16.at env (1+1+2+2+1+1+1+1))
      method set_checksum v : unit =
        Mpl_uint16.marshal (env_at env (1+1+2+2+1+1+1+1) 2) (Mpl_uint16.of_int v)

      method src =
        Mpl_uint32.to_int32 (Mpl_uint32.at env (1+1+2+2+1+1+1+1+2))
      method set_src v : unit =
        Mpl_uint32.marshal (env_at env (1+1+2+2+1+1+1+1+2) 4) (Mpl_uint32.of_int32 v)

      method dest =
        Mpl_uint32.to_int32 (Mpl_uint32.at env (1+1+2+2+1+1+1+1+2+4))
      method set_dest v : unit =
        Mpl_uint32.marshal (env_at env (1+1+2+2+1+1+1+1+2+4) 4) (Mpl_uint32.of_int32 v)

      method options =
        Mpl_raw.at env (1+1+2+2+1+1+1+1+2+4+4) options_length
      (* set_options unsupported for now (type byte array) *)
      method options_env : env = env_at env (1+1+2+2+1+1+1+1+2+4+4) options_length
      method options_frag = Mpl_raw.frag env (1+1+2+2+1+1+1+1+2+4+4) options_length
      method options_length = options_length

      method header_end = 1+1+2+2+1+1+1+1+2+4+4+options_length

      method data =
        Mpl_raw.at env (1+1+2+2+1+1+1+1+2+4+4+options_length) data_length
      (* set_data unsupported for now (type byte array) *)
      method data_env : env = env_at env (1+1+2+2+1+1+1+1+2+4+4+options_length) data_length
      method data_frag = Mpl_raw.frag env (1+1+2+2+1+1+1+1+2+4+4+options_length) data_length
      method data_length = data_length


      method prettyprint =
        let out = prerr_endline in
        out "[ Ipv4.ipv4 ]";
        (* __bitdummy0 : bound *)
        (* version : bound *)
        (* ihl : bound *)
        (* __bitdummy1 : bound *)
        out ("  tos_precedence = " ^ (tos_precedence_to_string self#tos_precedence));
        out ("  tos_delay = " ^ (tos_delay_to_string self#tos_delay));
        out ("  tos_throughput = " ^ (tos_throughput_to_string self#tos_throughput));
        out ("  tos_reliability = " ^ (tos_reliability_to_string self#tos_reliability));
        (* tos_reserved : bound *)
        (* length : bound *)
        out ("  id = " ^ (Printf.sprintf "%u" self#id));
        (* __bitdummy2 : bound *)
        (* reserved : bound *)
        out ("  dont_fragment = " ^ (Printf.sprintf "%u" self#dont_fragment));
        out ("  can_fragment = " ^ (Printf.sprintf "%u" self#can_fragment));
        (* __bitdummy3 : bound *)
        out ("  frag_offset = " ^ (Printf.sprintf "%u" self#frag_offset));
        out ("  ttl = " ^ (Printf.sprintf "%u" self#ttl));
        out ("  protocol = " ^ (protocol_to_string self#protocol));
        out ("  checksum = " ^ (Printf.sprintf "%u" self#checksum));
        out ("  src = " ^ (Printf.sprintf "%lu" self#src));
        out ("  dest = " ^ (Printf.sprintf "%lu" self#dest));
        out ("  options = " ^ (Mpl_raw.prettyprint self#options));
        (* header_end : bound *)
        out ("  data = " ^ (Mpl_raw.prettyprint self#data));
        ()
    end

  let t
    ?(tos_precedence=`Routine)
    ?(tos_delay=`Normal)
    ?(tos_throughput=`Normal)
    ?(tos_reliability=`Normal)
    ~id
    ?(dont_fragment=0)
    ?(can_fragment=0)
    ?(frag_offset=0)
    ~ttl
    ~protocol
    ?(checksum=0)
    ~src
    ~dest
    ~(options:data)
    ~(data:data)
    env =
      (* let dest___offset = 1+1+2+2+1+1+1+1+2+4+4 in *)
      let ___env = env_at env (1+1+2+2+1+1+1+1+2+4+4) 0 in
      let options___len = match options with 
      |`Str x -> Mpl_raw.marshal ___env x; String.length x
      |`Sub fn -> fn ___env; curpos ___env
      |`None -> 0
      |`Frag t -> Mpl_raw.blit ___env t; curpos ___env in
      let ___al = (4 - (options___len mod 4)) mod 4 in for i = 1 to ___al do
        Mpl_byte.marshal ___env (Mpl_byte.of_char '\000');
      done; let options___len = options___len + ___al in
      let options___offset = 1+1+2+2+1+1+1+1+2+4+4+options___len in
      let ___env = env_at env (1+1+2+2+1+1+1+1+2+4+4+options___len) 0 in
      let data___len = match data with 
      |`Str x -> Mpl_raw.marshal ___env x; String.length x
      |`Sub fn -> fn ___env; curpos ___env
      |`None -> 0
      |`Frag t -> Mpl_raw.blit ___env t; curpos ___env in
      let data___offset = 1+1+2+2+1+1+1+1+2+4+4+options___len+data___len in
      let version = 4 in (* const bit *)
      let ihl = (options___offset / 4) in (* bit bound *)
      let tos_precedence = tos_precedence_marshal tos_precedence in
      let tos_delay = tos_delay_marshal tos_delay in
      let tos_throughput = tos_throughput_marshal tos_throughput in
      let tos_reliability = tos_reliability_marshal tos_reliability in
      let tos_reserved = 0 in (* const bit *)
      let reserved = 0 in (* const bit *)
      if dont_fragment < 0 || dont_fragment > 1 then raise (Bad_packet "out of range (0 < dont_fragment < 1)");
      if can_fragment < 0 || can_fragment > 1 then raise (Bad_packet "out of range (0 < can_fragment < 1)");
      if frag_offset < 0 || frag_offset > 8191 then raise (Bad_packet "out of range (0 < frag_offset < 8191)");
      let __bitdummy2 = Mpl_byte.of_int ((frag_offset lsr 8) + (can_fragment lsl 5) + (dont_fragment lsl 6) + (reserved lsl 7)) in
      let __bitdummy3 = Mpl_byte.of_int ((frag_offset land 255)) in
      let __bitdummy0 = Mpl_byte.of_int (ihl + (version lsl 4)) in
      let __bitdummy1 = Mpl_byte.of_int (tos_reserved + (tos_reliability lsl 2) + (tos_throughput lsl 3) + (tos_delay lsl 4) + (tos_precedence lsl 5)) in
      let length = (Mpl_uint16.of_int data___offset) in (* bound *)
      let id = (Mpl_uint16.of_int id) in
      let ttl = (Mpl_byte.of_int ttl) in
      let __protocol = protocol_marshal protocol in
      let __protocol = (Mpl_byte.of_int __protocol) in
      let checksum = (Mpl_uint16.of_int checksum) in
      let src = (Mpl_uint32.of_int32 src) in
      let dest = (Mpl_uint32.of_int32 dest) in
      (* let options = options in *)
      (* let data = data in *)
      Mpl_byte.marshal env __bitdummy0;
      (* bit version *)
      (* bit ihl *)
      Mpl_byte.marshal env __bitdummy1;
      (* bit tos_precedence *)
      (* bit tos_delay *)
      (* bit tos_throughput *)
      (* bit tos_reliability *)
      (* bit tos_reserved *)
      Mpl_uint16.marshal env length;
      Mpl_uint16.marshal env id;
      Mpl_byte.marshal env __bitdummy2;
      (* bit reserved *)
      (* bit dont_fragment *)
      (* bit can_fragment *)
      Mpl_byte.marshal env __bitdummy3;
      (* bit frag_offset *)
      Mpl_byte.marshal env ttl;
      Mpl_byte.marshal env __protocol;
      Mpl_uint16.marshal env checksum;
      Mpl_uint32.marshal env src;
      Mpl_uint32.marshal env dest;
      skip env options___len;
      skip env data___len;
      new o
      ~options_length:options___len
      ~data_length:data___len
      env

  let m (x:(env->o)) env = x env
  let sizeof (x:o) = x#sizeof
  let prettyprint (x:o) = x#prettyprint
  let env (x:o) = x#env

  let unmarshal 
    (env:env) : o =
    let __bitdummy0 = Mpl_byte.to_int (Mpl_byte.unmarshal env) in
    let ihl = (((__bitdummy0 lsr 0) land 15) lsl 0) in (* bitu *)
    skip env 1; (* skipped __bitdummy1 *)
    let length = Mpl_uint16.unmarshal env in
    skip env 2; (* skipped id *)
    skip env 1; (* skipped __bitdummy2 *)
    skip env 1; (* skipped __bitdummy3 *)
    skip env 1; (* skipped ttl *)
    skip env 1; (* skipped protocol *)
    skip env 2; (* skipped checksum *)
    skip env 4; (* skipped src *)
    skip env 4; (* skipped dest *)
    let dest___offset = curpos env in
    let options_length = ((ihl * 4) - dest___offset) in
    skip env options_length; (* skipped options *)
    (* let options___offset = curpos env in *)
    skip env 0; (* skipped header_end *)
    let data_length = ((Mpl_uint16.to_int length) - (ihl * 4)) in
    skip env data_length; (* skipped data *)
    (* let data___offset = curpos env in *)
    new o env
    ~options_length:options_length
    ~data_length:data_length
end

